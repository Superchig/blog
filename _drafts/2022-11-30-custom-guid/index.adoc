= Custom GUIDs in Unity
:toc:

// Interestingly, someone at Unity already has a GUID component setup, though I
// didn't learn about it until recently:
// https://github.com/Unity-Technologies/guid-based-reference
// Also, this approach doesn't have a manager, though I'm not sure if this
// actually needs to use this manager?

== Introduction

If you've ever tried to save data for a large number of entities in a
video game, you've probably come across an approach that looks like this:

1. Associate each entity with a persistent, unique ID.
2. Create a key-value store (like a Python dictionary), using these IDs as keys
and records with the relevant data for each entity as values.
3. Write the key-value store to disk / read the key-value store from disk as
necessary.

It's possible to go into significantly more detail for each of these steps, but
this article will focus primarily on the first one: assigning persistent, unique
IDs.

== The Problem

Specifically, this article will explain how to create a MonoBehaviour script
which, when attached to a GameObject, will assign it a unique ID that persists
between different play sessions.

With a script like this, you would want these IDs to be unique even in the
following situations:

1. A developer duplicates a GameObject (in the editor).
2. A developer converts a GameObject into a prefab (in the editor).
3. A developer instantiates a prefab (in the editor).

If a normal MonoBehaviour script were attached to the GameObject in any of these
cases, then the fields on that script would be duplicated along with the
GameObject.

You would have GameObjects with the same IDs as their prefabs, or duplicate
GameObjects with identical IDs. This would make it impossible to save/load data
for individual GameObjects.

== GUIDs

First of all, let's settle what a GUID is. In short, a GUID (also known as a
https://en.wikipedia.org/wiki/Universally_unique_identifier[UUID]) is a 128-bit
data structure that represents a globally unique ID.

As the name of this article implies, we'll be using GUIDs as our IDs in this
article.

Specifically, we'll be (automatically) creating these GUIDs in the editor, so
that the specific GUID value for each GameObject is part of its scene. This will
keep these GUIDs the same every time the player plays the game.

Unity already uses GUIDs to refer to different assets in the editor (and you can
actually see them in use if you look into the .meta or .asset files in a Unity
project).

It's worth nothing that Unity already creates unique IDs to refer to each
GameObject. However, these IDs will change between
https://docs.unity3d.com/ScriptReference/Object.GetInstanceID.html[player
runtime and Editor sessions], making them useless for the purposes of
saving/loading data.

// FIXME(Chris): Mention that we'll be using the C# standard library's GUID
// type, which comes with an easy method to generate new IDs

== The ExecuteAlways Attribute

In Unity, our C# scripts typically run during a player's runtime session.
That is, they execute code either when we play the game in the editor or when
the player is running an actual build.

Since we're creating GUIDs in the editor, we'll need to execute some code in the
editor itself. That is, we'll want the script to execute before we even start
the game, as we create prefabs or instantiate GameObjects while in the editor.
To achieve this, we'll use
https://docs.unity3d.com/ScriptReference/ExecuteAlways.html[the `ExecuteAlways`
attribute].

It's worth noting that there is an
https://docs.unity3d.com/2021.3/Documentation/ScriptReference/ExecuteInEditMode.html[older
and similar attribute called `ExecuteInEditMode`], which has been deprecated.
Annoyingly, this deprecation warning only shows up in the middle of its
documentation (at least for Unity version 2021.3).

The ExecuteAlways attribute is fairly straightforward. This example is taken
from Unity's documentation for the attribute:

[source,csharp]
----
using UnityEngine;

[ExecuteAlways]
public class ExampleClass : MonoBehaviour
{
    void Start()
    {
        if (Application.IsPlaying(gameObject))
        {
            // Play logic
        }
        else
        {
            // Editor logic
        }
    }
}
----

Since this class has been marked with `ExecuteAlways`, it will potentially
execute code at both runtime and in the editor itself.

To execute different code between runtime and the editor, we can use the
`Application.IsPlaying` method, passing the script's own GameObject as an
argument. This method will return true if we're in a play session, and it will
return false if we're only in the editor.

=== Start and Update

With a normal script, the `Start` and `Update` methods execute when the scene is
loaded and every frame, respectively. Both of these methods only run during a
play session. With the `ExecuteAlways` attribute, these methods will execute
in the editor as well as during a play session. Specifically:

- In the editor, `Start` will execute when a script is first attached to a
  GameObject and when the scene is loaded.
- In the editor, `Update` will be called whenever something in the scene is
  changed.

We'll be using both of these methods in our script. Though we could conceptually
do everything in `Update`, we'll use `Start` to perform particularly expensive
operations as a performance optimization.

== SerializedProperty and SerializedObject

With these concepts already explained, let's start the actual script:

[source,csharp]
----
// Imports...

[ExecuteAlways]
public class CustomGUID : MonoBehaviour
{
    public string guid;

    // Hasn't been implemented yet...
}
----

As you can see, all we really have of note is a string field called `guid`.
Though `Guid` already exists as a part of
https://learn.microsoft.com/en-us/dotnet/api/system.guid?view=net-7.0[C#'s
standard library] (and we'll be using this type to generate our GUIDs), we'll be
storing them as strings for a few reasons:

1. Unity's built-in serialization doesn't directly support `Guid` fields, but it
   does support strings.
2. By directly serializing strings, we can easily view the GUIDs in the editor
   itself, seeing the typical hexadecimal representation for a GUID.

=== A Naive (and Somewhat Buggy) Approach

Under normal circumstances, you would update this `guid` field by simply
assigning to it:

[source,csharp]
----
// Imports...

[ExecuteAlways]
public class CustomGUID : MonoBehaviour
{
    public string guid;

    private void Awake()
    {
        if (/* Some condition */) {
            // Assign a new GUID as necessary
	    guid = Guid.NewGuid().ToString();
        }
    }
}
----

When simply assigning to GameObjects or duplicating them, this code will assign
GUIDs properly.

=== Bug: Prefabs

However, when this CustomGUID script is attached to a prefab, an annoying bug
will appear: the script will be unable to properly read from the `guid` field.

// FIXME(Chris): Rewrite this numbered list out of existence

That is, when attached to a prefab:

1. The script will always consider the `guid` to initially be `null`, even if
the field has previously been set to an actual GUID.
2. This makes it difficult to detect when we should generate a new GUID (more on
this later).

// FIXME(Chris): Discuss how we don't want the GUID to change every time we load
// a scene, which will (among other things) pollute our commits

To remedy this, we will use parts of the Unity API that are normally seen in
custom editors: the
https://docs.unity3d.com/2021.3/Documentation/ScriptReference/SerializedObject.html[SerializedObject]
and
https://docs.unity3d.com/2021.3/Documentation/ScriptReference/SerializedProperty.html[SerializedProperty]
classes.

=== Why Use SerializedObject and SerializedProperty?

In short, `SerializedObject` and `SerializedProperty` are how you're supposed to
modify the fields of a MonoBehavior script when executing code in the Unity
editor itself. When used, they will automatically support key editor
functionality like undo and prefab overrides.

For our use case, we're more interested in the fact that these classes avoid the
prefab field-reading bug mentioned earlier.

// The `SerializedObject` and `SerializedProperty` APIs are a little clunky, so
// we'll 

=== Editor API: SerializedObject

As its name might imply, `SerializedObject` represents an object and will
indirectly allow us to modify the fields in this object. Specifically, it
represents an object that descends from the `Object` class
https://docs.unity3d.com/2021.3/Documentation/ScriptReference/Object.html[provided
by Unity].

It's worth noting that C# also provides an `Object` class, and that
https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-7.0[all
classes in C# inherit from this class]. Somewhat confusingly, this `Object`
class is *not* the `Object` class provided by Unity.

Both GameObjects and MonoBehavior scripts descend from Unity's `Object` class,
so we'll be able to use `SerializedObject` to represent the script that we want
to modify.

Concretely speaking, we'll only directly use a `SerializedObject` to gain access
to a `SerializedProperty`.

// TODO(Chris): Improve styling for 3-equals (`===`) sections, making them
// smaller than 2-equals and possibly a different color (dark yellow?)

=== Editor API: SerializedProperty

The `SerializedProperty` class allows us to actually modify an object's field.
However, in order to obtain it, we first need to create a `SerializedObject`
(which is why I introduced a `SerializedObject` first).

While using this part of the Editor API, we need to follow these 4 broad steps
to modify an object's field:

1. Obtain a `SerializedObject` that represents our MonoBehavior script.
2. Obtain a `SerializedProperty` from the `SerializedObject` that represents a
   specific field.
3. Tell the `SerializedProperty` that you want to change the relevant field.
4. Finalize your changes via the `SerializedObject`.

The following example code will show how to set a GUID via this part of the
Editor API:

[source,csharp]
----
using UnityEditor;
// Other Imports...

[ExecuteAlways]
public class CustomGUID : MonoBehaviour
{
    public string guid;

    private void Awake()
    {
        if (/* Some condition */) {
            // Assign a new GUID as necessary

            // By passing `this` into the constructor, we give our
            // SerializedObject access to our CustomGUID script.
            SerializedObject serializedObject = new SerializedObject(this);

            // `guidProperty` will correspond to our `guid` property in our
            // CustomGUID script.
            SerializedProperty guidProperty =
                serializedObject.FindProperty("guid");
            
            // This is where we actually generate and assign a new GUID.
            guidProperty.stringValue = Guid.NewGuid().ToString();

            // For any of our modifications to successfully last, we need to
            // call `ApplyModifiedProperties()`. without this, none of our
            // properties will actually be changed in our CustomGUID script.
            serializedObject.ApplyModifiedProperties();
        }
    }
}
----

Note that, in order to use these 2 classes, we need a `using UnityEditor`
statement.

=== Problem: We Can't Build!

If you tried to build a project that uses `SerializedObject` and
`SerializedProperty` in a MonoBehavior script (as we demonstrated above), you
would run into an annoying problem: the project would fail to build entirely.

== C# Preprocessor Directives

// FIXME(Chris): Talk about how the documentation explicitly says that
// UnityEditor can't be referenced by runtime code compiled into a playable
// game.

== The nameof Expression

== PrefabStageUtility
