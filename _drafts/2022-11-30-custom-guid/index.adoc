= Custom GUIDs in Unity
:toc:

// Interestingly, someone at Unity already has a GUID component setup, though I
// didn't learn about it until recently:
// https://github.com/Unity-Technologies/guid-based-reference
// Also, this approach doesn't have a manager, though I'm not sure if this
// actually needs to use this manager?

== Introduction

If you've ever tried to save data for many entities in a video game, you've
probably come across an approach that looks like this:

1. Associate each entity with a persistent, unique ID.
2. Create a key-value store (like a Python dictionary), using these IDs as keys
and records with the relevant data for each entity as values.
3. Write the key-value store to disk / read the key-value store from disk as
necessary.

It's possible to go into significantly more detail for each of these steps, but
this article will focus primarily on the first one: assigning persistent, unique
IDs.

[#the-problem]
== The Problem

Specifically, this article will explain how to create a MonoBehaviour script
which, when attached to a GameObject, will assign it a unique ID that persists
between different play sessions.

With a script like this, you would want these IDs to be unique even in the
following situations:

1. A developer duplicates a GameObject (in the editor).
2. A developer converts a GameObject into a prefab (in the editor).
3. A developer instantiates a prefab (in the editor).

If a normal MonoBehaviour script were attached to the GameObject in any of these
cases, then the fields on that script would be duplicated along with the
GameObject.

You would have GameObjects with the same IDs as their prefabs, or duplicate
GameObjects with identical IDs. This would make it impossible to save/load data
for individual GameObjects.

== GUIDs

First of all, let's settle what a GUID is. In short, a GUID (also known as a
https://en.wikipedia.org/wiki/Universally_unique_identifier[UUID]) is a 128-bit
data structure that represents a globally unique ID.

As the name of this article implies, we'll be using GUIDs as our IDs in this
article.

Specifically, we'll be (automatically) creating these GUIDs in the editor, so
that the specific GUID value for each GameObject is part of its scene. This will
keep these GUIDs the same every time the player plays the game.

Unity already uses GUIDs to refer to different assets in the editor (and you can
actually see them in use if you look into the .meta or .asset files in a Unity
project).

It's worth nothing that Unity already creates unique IDs to refer to each
GameObject. However, these IDs will change between
https://docs.unity3d.com/ScriptReference/Object.GetInstanceID.html[player
runtime and Editor sessions], making them useless for the purposes of
saving/loading data.

== The ExecuteAlways Attribute

In Unity, our C# scripts typically run during a player's runtime session.
That is, they execute code either when we play the game in the editor or when
the player is running an actual build.

Since we're creating GUIDs in the editor, we'll need to execute some code in the
editor itself. That is, we'll want the script to execute before we even start
the game, as we create prefabs or instantiate GameObjects while in the editor.
To achieve this, we'll use
https://docs.unity3d.com/ScriptReference/ExecuteAlways.html[the `ExecuteAlways`
attribute].

It's worth noting that there is an
https://docs.unity3d.com/2021.3/Documentation/ScriptReference/ExecuteInEditMode.html[older
and similar attribute called `ExecuteInEditMode`], which has been deprecated.
Annoyingly, this deprecation warning only shows up in the middle of its
documentation (at least for Unity version 2021.3).

=== Example: ExecuteAlways

The syntax for the ExecuteAlways attribute is fairly straightforward. This
example is taken from Unity's documentation for the attribute:

[source,csharp]
----
using UnityEngine;

[ExecuteAlways]
public class ExampleClass : MonoBehaviour
{
    void Start()
    {
        if (Application.IsPlaying(gameObject))
        {
            // Play logic
        }
        else
        {
            // Editor logic
        }
    }
}
----

As seen on line 3, this class has been marked with `ExecuteAlways`. As a result,
it now has the ability to execute code at both runtime and in the editor itself.

To execute different code between runtime and the editor, we can use the
`Application.IsPlaying` method, passing the script's own GameObject as an
argument. This method will return true if we're in a play session, and it will
return false if we're only in the editor.

=== Start, Awake, and Update

With a normal script, the `Start`, `Awake`, `Update` methods execute when the scene is
loaded and every frame, respectively. Both of these methods only run during a
play session. With the `ExecuteAlways` attribute, these methods will execute
in the editor as well as during a play session. Specifically:

- In the editor, `Start` will execute when a script is first attached to a
  GameObject and when the scene is loaded.
- In the editor, `Awake` behaves similarly to `Start`, except that it is
  executed first and it will execute even if the script component is disabled.
- In the editor, `Update` will be called whenever something in the scene is
  changed.

We'll be using the `Awake` and `Update` methods in our script. Though we could
conceptually do everything in `Update`, we'll use `Awake` to perform
particularly expensive operations as a performance optimization.

=== Script Usage: ExecuteAlways

Let's start our actual script, using these features:

[source,csharp]
----
// Using statements...

[ExecuteAlways]
public class CustomGUID : MonoBehavior
{
    private void Awake()
    {
        if (!Application.IsPlaying(gameObject))
        {
            // Only in editor
        }
    }

    private void Update()
    {
        if (!Application.IsPlaying(gameObject))
        {
            // Only in editor
        }
    }
}
----

In this script, both our `Awake` and our `Update` methods will only execute code
in the editor. They won't execute any code when the player is actually playing
the game.

== Editor APIs: SerializedProperty and SerializedObject

We need the editor APIs to properly modify our GUID field from the editor, even
if the script is attached to prefab.

=== Script Usage: String Field For GUID

We'll store our GUIDs as strings, via a field:

[source,csharp]
----
// Using statements...

[ExecuteAlways]
public class CustomGUID : MonoBehaviour
{
    public string guid;

    // Awake and Update methods...
}
----

Though `Guid` already exists as a part of
https://learn.microsoft.com/en-us/dotnet/api/system.guid?view=net-7.0[C#'s
standard library] (and we'll be using this type to generate our GUIDs), we'll be
storing them as strings for a few reasons:

1. Unity's built-in serialization doesn't directly support `Guid` fields, but it
   does support strings.
2. By directly serializing strings, we can easily view the GUIDs in the editor
   itself, seeing the typical hexadecimal representation for a GUID.

=== A Naive (and Somewhat Buggy) Approach

Under normal circumstances, you would update this `guid` field by simply
assigning to it:

[source,csharp]
----
// Using statements...

[ExecuteAlways]
public class CustomGUID : MonoBehaviour
{
    public string guid;

    private void Awake()
    {
        if (!Application.IsPlaying(gameObject)) {
            // Assign a new GUID as necessary
	    guid = Guid.NewGuid().ToString();
        }
    }

    // Update method not implemented...
}
----

When simply assigning to GameObjects or duplicating them, this code will assign
GUIDs properly.

=== Bug: Prefabs

However, when this CustomGUID script is attached to a prefab, an annoying bug
will appear: the script will be unable to properly read from the `guid` field.

That is, when attached to a prefab, the script will always consider the `guid`
to initially be `null`, even if the prefab is actually storing a valid GUID in
the field. This makes it difficult to detect when we should generate a new GUID
(we'll discuss the exact algorithm for this later).

To solve this problem, we will use parts of the Unity API that are
normally seen in custom editors: the
https://docs.unity3d.com/2021.3/Documentation/ScriptReference/SerializedObject.html[SerializedObject]
and
https://docs.unity3d.com/2021.3/Documentation/ScriptReference/SerializedProperty.html[SerializedProperty]
classes.

=== Why Use SerializedObject and SerializedProperty?

In short, `SerializedObject` and `SerializedProperty` are how you're supposed to
modify the fields of a MonoBehavior script when executing code in the Unity
editor itself. When used, they will automatically support key editor
functionality like undo and prefab overrides.

For our use case, we're more interested in the fact that these classes avoid the
prefab field-reading bug mentioned earlier.

// The `SerializedObject` and `SerializedProperty` APIs are a little clunky, so
// we'll 

=== Editor API: SerializedObject

As its name might imply, `SerializedObject` represents an object and will
indirectly allow us to modify the fields in this object. Specifically, it
represents an object that descends from the `Object` class
https://docs.unity3d.com/2021.3/Documentation/ScriptReference/Object.html[provided
by Unity].

It's worth noting that C# also provides an `Object` class, and that
https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-7.0[all
classes in C# inherit from this class]. Somewhat confusingly, this `Object`
class is *not* the `Object` class provided by Unity.

Both GameObjects and MonoBehavior scripts descend from Unity's `Object` class,
so we'll be able to use `SerializedObject` to represent the script that we want
to modify.

Concretely speaking, we'll only directly use a `SerializedObject` to gain access
to a `SerializedProperty`.

// TODO(Chris): Improve styling for 3-equals (`===`) sections, making them
// smaller than 2-equals and possibly a different color (dark yellow?)

=== Editor API: SerializedProperty

The `SerializedProperty` class allows us to actually modify an object's field.
However, in order to obtain it, we first need to create a `SerializedObject`
(which is why I introduced a `SerializedObject` first).

While using this part of the Editor API, we need to follow these 4 broad steps
to modify an object's field:

1. Obtain a `SerializedObject` that represents our MonoBehavior script.
2. Obtain a `SerializedProperty` from the `SerializedObject` that represents a
   specific field.
3. Tell the `SerializedProperty` that you want to change the relevant field.
4. Finalize your changes via the `SerializedObject`.

The following example code will show how to set a GUID via this part of the
Editor API:

[source,csharp]
----
// Other using statements...
using UnityEditor;

[ExecuteAlways]
public class CustomGUID : MonoBehaviour
{
    public string guid;

    private void Awake()
    {
        if (!Application.IsPlaying(gameObject)) {
            // For now, always assign a new GUID

            // Step 1
            SerializedObject serializedObject = new SerializedObject(this);

            // Step 2
            SerializedProperty guidProperty =
                serializedObject.FindProperty("guid");
            
            // Step 3
            guidProperty.stringValue = Guid.NewGuid().ToString();

            // Step 4
            serializedObject.ApplyModifiedProperties();
        }
    }

    // Update method not implemented...
}
----

The 4 statements in our `Awake` method shown above correspond to the 4 steps
necessary for us to modify a field.

[#editor-api-problems]
There are two potentially problematic details here:

1. On lines 18/19, we obtain a SerializedProperty by searching for a field with
   the name `"guid"`. This may lead to bugs if we ever change the name of this
   field (which we will address later in this post).
2. On line 2, we have to use `using UnityEditor` statement, otherwise we won't
   have access to our 2 classes from the Editor API. This will lead to problems
   when making builds of our game (as we will shortly discuss).

=== Problem: We Can't Build!

If you tried to build a project that uses `SerializedObject` and
`SerializedProperty` in a MonoBehavior script (as we demonstrated above), you
would run into an annoying problem: the project would fail to build entirely.

Our problem most directly originates with our use of the `UnityEditor`
namespace. We need this namespace to access `SerializedObject` and
`SerializedProperty`, but, as stated in its
https://docs.unity3d.com/2021.3/Documentation/ScriptReference/UnityEditor.html[documentation],
we can't reference this namespace in scripts that are compiled for a
final build.

APIs in `UnityEditor` are typically used in when writing custom Editors in
Unity. In our case, we're not doing this. Instead, we're using these APIs in a
MonoBehavior script that has been annotated with the `ExecuteAlways` attribute.
As with normal MonoBehavior scripts, our script will be compiled when making a
build.

Here's a key insight: even though our `CustomGUID` script will be compiled for a
user-facing build, only part of its functionality needs to be available when the
game is running.

1. In the game itself: we need access to the GUID for each relevant GameObject.
   This does not require any of the Editor APIs. This essentially just requires
   the `guid` field.
2. In the editor: we need to ensure that the GUIDs attached to GameObjects are
   unique, even when a GameObject is duplicated or instantiated from a prefab.
   This will require the Editor APIs, so that we can properly assign to the
   `guid` field from the editor itself.

With this in mind, we can make a key conclusion: we only need the Editor APIs
while in the editor itself.

== C# Preprocessor Directives

In order to make our project build properly, we'll be using something called
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives[C#
preprocessor directives].

With this feature of C# (and its integration with Unity), we can avoid compiling
the editor-specific part of our script in player-facing builds.

=== Example: C# Preprocessor Directives

Let's look at a brief of example of the relevant syntax:

[source,csharp]
----
#if UNITY_EDITOR

    Debug.Log("Hello, editor!");

#endif

----

In the example above, the `#if UNITY_EDITOR` and `#endif` lines are preprocessor
directives{empty}footnote:[These are called preprocessor directives because they
are heavily inspired by a similar mechanism associated with the C programming
language. When programming with C, the preprocessor performs "dumb" textual
manipulation of the source code before the compiler actually parses and compiles
the anything into machine code. Traditionally, the preprocessor was a separate
program entirely, being invoked by the compiler before anything else was done.
pass:p[ +]
pass:p[ +]
In pass:[C#], the compiler doesn't use a separate preprocessor, but it does
process each of these directives as if there were a separate program running
before the rest of the compiler.]. With these directives, the `Debug.Log("Hello,
editor!")` line will only compile within the editor itself. When we make a full
build for the game, this line (and everything between these two directives)
won't be compiled at all. From the compiler's point of view, it'll be as if
these lines simply aren't in our source code.

This technique is called
https://docs.unity3d.com/2021.3/Documentation/Manual/PlatformDependentCompilation.html[conditional ]
https://en.wikipedia.org/wiki/Conditional_compilation[compilation],
as it only compiles parts of the code when certain conditions are
true (like being in the Unity Editor or not).

[#script-usage-preprocessor]
=== Script Usage: C# Preprocessor Directives

Now that we have an understanding of the syntax, let's use C# preprocessor
directives in our script itself:

[source,csharp]
----
// Other using statements...

#if UNITY_EDITOR
using UnityEditor;
#endif

[ExecuteAlways]
public class CustomGUID : MonoBehaviour
{
    public string guid;

#if UNITY_EDITOR
    private void Awake()
    {
        if (!Application.IsPlaying(gameObject)) {
            // For now, always assign a new GUID

            SerializedObject serializedObject = new SerializedObject(this);

            SerializedProperty guidProperty =
                serializedObject.FindProperty("guid");
            
            guidProperty.stringValue = Guid.NewGuid().ToString();

            serializedObject.ApplyModifiedProperties();
        }
    }
#endif

    // Update method not implemented...
}
----

There are 2 blocks of code that we conditionally compile, since both of them
involve the Editor APIs:

1. The `using UnityEditor` statement.
2. The `Awake` method.

When we're in our editor, both of these sections of code will compile, ensuring
that our script can assign different GUID values as necessary.

When making a final build, however, both of sections of code will be ignored,
leaving our script with no references to `UnityEditor` or anything in that
namespace. This will allow us to successfully create a final build.

== The nameof Expression

As we <<editor-api-problems, mentioned earlier>>, we have to obtain a
SerializedProperty by searching for a field with the name `"guid"`. If we were
to change the name of our field (e.g. from `"guid"` to `"id"`), then we would
need to change the argument passed to `serializedObject.FindProperty()` as well.

Fortunately, we can automatically obtain the name of our `guid` field using a
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/nameof[feature
of C#] called the `nameof` expression.

As its name would imply, this expression allows us to obtain the name of a
variable, type, or field as a string constant.

=== Script Usage: nameof

Let's use this feature in our script:

[source,csharp]
----
// Other using statements...

#if UNITY_EDITOR
using UnityEditor;
#endif

[ExecuteAlways]
public class CustomGUID : MonoBehaviour
{
    public string guid;

#if UNITY_EDITOR
    private void Awake()
    {
        if (!Application.IsPlaying(gameObject)) {
            // For now, always assign a new GUID

            SerializedObject serializedObject = new SerializedObject(this);

            SerializedProperty guidProperty =
                serializedObject.FindProperty(nameof(guid));
            
            guidProperty.stringValue = Guid.NewGuid().ToString();

            serializedObject.ApplyModifiedProperties();
        }
    }
#endif

    // Update method not implemented...
}
----

Compared to our <<script-usage-preprocessor, previous example>>, we've only
changed one line: line 20.

Specifically, changed our use of `"guid"` to `nameof(guid)`. This will have the
same functionality while being more robust.

If we were to rename the `guid` field (perhaps to `id`) in our IDE, then our IDE
would automatically use the new name on line 20 for us. By using this feature,
we no longer need to worry about changing the argument to
`serializedObject.FindProperty()`.

[#stop-constant-change]
== Stop Constantly Changing GUIDs Handling Duplication

Up to this point, you may have noticed a possible quirk in our implementation:
we assign a new GUID to each GameObject every time we load a scene
(or fully open up a prefab).

There are a few annoying issues with this approach:

- Whenever leaving a scene, the Unity editor will ask if we want to save, even
  if it doesn't seem like we've changed anything (as the GUIDs of the
  GameObjects will have changed).
- Our commits in git will constantly show scenes and prefabs being changed, even
  if we didn't apparently modify them (as the GUIDs of their GameObjects will
  have changed upon opening them).

To solve these issue, we'll use a different approach entirely: we'll only modify
a GameObject's GUID as necessary.

== Handling Duplication

As we mentioned <<the-problem, near the beginning of this post>>, we need to
ensure that the GUID is different when a GameObject is duplicated.

Normally, when a GameObject is duplicated, all of the fields in its attached
scripts are duplicated as well.

However, we want the `guid` in field in our `CustomGUID` script GameObject to
*not* be duplicated (as this stores our GameObject's GUID). How can we achieve
this?

Ideally, we would want to run code to generate a new GUID whenever the
GameObject is duplicated. Unfortunately, Unity doesn't provide any direct ways
to achieve this.

https://answers.unity.com/questions/483434/how-to-call-a-method-when-a-gameobject-has-been-du.html[This
forum post] seems to describe an indirect way to do this, but the approach shown
there will also run code when a scene is first entered, so it's not viable for
our use case. (If we generated a new GUID whenever we entered a scene, then our
GameObjects would change GUIDs constantly, leaving us with the annoying issues
<<stop-constant-change, from earlier>>.)

=== Script Usage: Handling Duplication

Since we can't run code specifically when a GameObject is being duplicated,
we'll simply have each `CustomGUID` script check the other GUIDs to see if our
current GUID is a duplicate:

[source,csharp]
----
// Just the Awake method is shown here

#if UNITY_EDITOR
    private void Awake()
    {
        if (!Application.IsPlaying(gameObject))
        {
            SerializedObject serializedObject = new SerializedObject(this);

            SerializedProperty guidProperty =
                serializedObject.FindProperty(nameof(guid));

            // Potential performance problem, but fine for dozens of GameObjects
            CustomGUID[] customGuids = FindObjectsOfType<CustomGUID>();
            foreach (CustomGUID customGuid in customGuids)
            {
                if (customGuid.guid == guid && customGuid != this)
                {
                    guidProperty.stringValue = NewGuid();
                }
            }

            serializedObject.ApplyModifiedProperties();
        }
    }
#endif

----

Though this approach will correctly prevent duplicate GameObjects from having
the same GUIDs, it has a potential performance problem. As each `CustomGUID`
will have to check all of our `CustomGUID` scripts. This will have a run time of
O(n^2^), which will be abysmal with large numbers of `CustomGUID` scripts (i.e.
large numbers of GameObjects with `CustomGUID` scripts attached).

Perhaps due to the speed of modern computers (and the fact that this code is in
`Awake` rather than `Update`), this performance is fine when you have dozens and
dozens of GameObjects in your scene. However, as you approach hundreds of
GameObjects, the performance problems become significantly worse, at least on
the gaming laptop I used for testing.

To solve this performance problem, you can cache the GUIDs that have been used
so far. Using a Dictionary or a
https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1?view=net-7.0[HashSet]
in a static variable for this cache will allow you to achieve rapid look-ups,
allowing you to avoid linearly iterating through all CustomGUIDs from every
CustomGUID.

This post is primarily focused on the core ideas and features used to set up
persistent GUIDs in Unity, and the underlying approach to handling duplication
is the same. So I won't go into too much detail regarding this optimization. The
approach used here is optimized enough to see examples in use.

== Handling New GameObjects

When first attaching a `CustomGUID` script to a GameObject, we obviously need to
assign a GUID.

To avoid having a new GUID every time we load the scene, we'll use `null` as the
default value for our `guid` field (`null` is the default value for a string
field) and then initialize `guid` if it has not been initialized before:

[source,csharp]
----
// Inside the CustomGUID class

#if UNITY_EDITOR
    private void Update()
    {
        if (!Application.IsPlaying(gameObject))
        {
            SerializedObject serializedObject = new SerializedObject(this);

            SerializedProperty guidProperty =
                serializedObject.FindProperty(nameof(guid));

            if (String.IsNullOrEmpty(guidProperty.stringValue))
            {
                guidProperty.stringValue = NewGuid();
            }

            serializedObject.ApplyModifiedProperties();
        }
    }
#endif

----

Additionally, since we're now generating GUIDs in more than one place, let's
refactor that code into its own little method:

[source,csharp]
----
    // Inside the CustomGUID class

    private string NewGuid()
    {
        return Guid.NewGuid().ToString();
    }
----

It's fine for us to place this code in Update, since checking the GUID every
time something in the scene changes is cheap--cheap enough to be negligible.

In the `Update` method, we reuse many of the same features we saw before: Editor
APIS (`SerializedObject` and `SerializedProperty`), the `nameof` expression, and
part of what `ExecuteAttribute` offers (`Application.IsPlaying`). Since we're
familiar with these features already, our functionality is fairly straightforward.

The only particularly new detail is the use of `String.IsNullOrEmpty`. This is
just a little utility function from
https://learn.microsoft.com/en-us/dotnet/api/system.string.isnullorempty?view=net-7.0[C#'s
standard library] which checks if a string is `null` or empty.

Checking for an empty string is useful for debugging purposes, as it allows us
to force new GUIDs to be generated from the editor. Simply by clearing the
`guid` field from the Inspector window, we can force this script to generate a
new GUID. This benefit is also only possible in the `Update` method. If we were
to place this check in the `Awake` method, we wouldn't see an instant response.

== PrefabStageUtility

== Further Reading
