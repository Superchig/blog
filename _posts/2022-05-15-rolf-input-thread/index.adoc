= Rolf: User Input, Threads, and Channels

:fn-large: footnote:[Rolf doesn't necessarily load insanely large images, but there can be a noticeable loading time. Going forward, we might want to use a https://lib.rs/crates/mozjpeg[faster JPEG decoder].]

Assume that you’re writing a TUI application (like
https://github.com/Superchig/rolf[`rolf`]) which does at least two
things:

1. Respond to user input, and
2. Load in incredibly large{fn-large} images.

If you’re working on a program like this, you might run into an annoying
problem: users have to wait for images to load before they can do
anything.

The solution to this problem is to asynchronously obtain user input.

Depending on your runtime (e.g.
https://thecodest.co/blog/asynchronous-and-single-threaded-javascript-meet-the-event-loop/[nodejs]),
it’s possible to be both asynchronous and single-threaded.

However, for the purposes of `rolf`, we used multiple threads to handle
asynchronous input.

== Architecture

For the purposes of this post, let's say that there are 3 threads
involvedfootnote:[`rolf` actually uses more threads than the ones shown here,
but they're not relevant to this post.].

image:/assets/2022-05-15-rolf-input-thread/threads.png[]

As seen in the diagram above, we have a thread for:

- Receiving user input,
- Decoding images,
- And everything else (the Main thread)

You might also notice that the Input and Image Decoding threads only interact
with the Main thread, sending data back and forth to each other.

The Input and Main threads will both run on "infinite" loops. The Input thread
will wait for user input, sending it to the Main thread as necessary, and the
Main thread will wait for either input data from the Input thread or decoded
image data from the Image Decoding thread, processing this data as necessary.

Notably, we achieve all of this without polling, instead using channels to send
data between threads.

Our Main thread will simply be the initial thread of the program, and our two
other threads will be started by the Main thread.

== Channels

Before starting the loops for either of the threads (in fact, before starting
any additional threads beyond the Main one), we're going to create a few
channels.

[source,rust]
----
let (tx, rx) = channel();

let (to_input_tx, from_main_rx) = sync_channel(0);
----

Here, we've created two channels:

- One which we'll use for sending data to the Main thread,
- And another which we'll use for sending data to the Input thread.

Since channels only send information in one direction, we need two channels if
we want bidirectional communication between the Input thread and the Main
thread. Why do we want bidirectional communication in the first place? Well
discuss that more later.

From our point of view, each channel consists of a sender and a receiver.

- For the first channel, `tx` will be our sender and `rx` will be our receiver.
- For the second channel, `to_input_tx` is our sender and `from_main_rx` is our
  receiver.

Notably, we use a different function to create each of our channels. I'm not
sure if this is actually necessary, but this allows us to create
asynchronous/infinitely buffered vs. synchronous/bounded channels. The
distinction won't matter massively for the purposes of this blog post, but you
can read more about it https://doc.rust-lang.org/std/sync/mpsc/[here].

== Data Between Channels

Before we actually use the channels to send data between threads, let's first
establish the types of data that will be sent.

[source,rust]
----
enum InputEvent {
    CrosstermEvent {
        event: crossterm::event::Event,
        input_request_count: usize,
    },
    // Other events...
}
----

[source,rust]
----
enum InputRequest {
    RequestNumber(usize),
    Quit,
}
----

== Starting The Input Thread

Now that we've created some channels, it's time to start the input loop.

Specifically, we'll start the input loop in its own thread, the Input thread.

[source,rust]
----
let crossterm_input_tx = tx.clone();

std::thread::spawn(move || {
    loop {
        let input_request_count = match from_main_rx.recv() {
            Ok(InputRequest::RequestNumber(input_request_count)) => input_request_count,
            Ok(InputRequest::Quit) => break,
            Err(err) => panic!("Input thread: Lost connnection to main thread: {:?}", err),
        };

        let crossterm_event = event::read().expect("Unable to read crossterm event");

        crossterm_input_tx
            .send(InputEvent::CrosstermEvent {
                event: crossterm_event,
                input_request_count,
            })
            .expect("Unable to send on channel");
    }
});
----

*Note*: Have I made any typos? Am I blatantly wrong about something? Do
you just have general feedback? I’m still a Rust novice (arguably a
programming novice, in general), so feel free to email me at
mailto:chiggiechang@gmail.com[`chiggiechang@gmail.com`]. But be polite,
please!
